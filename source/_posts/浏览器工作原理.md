
---
title: 浏览器工作原理
date: 2017-05-19

---

## 浏览器的主要构成

1. 用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。
2. 浏览器引擎 － 用来查询及操作渲染引擎的接口。
3. 渲染引擎 － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。
4. 网络 － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。
5. UI后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。
6. JS解释器 － 用来解释执行JS代码。
7. 数据存储 － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术

需要注意的是，不同于大部分浏览器，Chrome为每个Tab分配了各自的渲染引擎实例，每个Tab就是一个独立的进程。

## 渲染引擎（The rendering engine）

渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。

#### 渲染引擎在取得内容之后的基本流程：
解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树

渲染引擎开始解析html，并将标签转化为内容树中的dom节点。接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树。

Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。

Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。

> 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

### DOM
输出的树，也就是解析树，是由DOM元素及属性节点组成的。

DOM是文档对象模型的缩写，它是html文档的对象表示，作为html元素的外部接口供js等调用。

树的根是“document”对象。

## 绘制（Painting）

### CSS盒模型
CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。

每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域


### CSS解析（CSS parsing）





### 包含内联样式和内联脚本的 HTML 文档

如果 HTML 文档中存在内联样式和脚本，这个时候，问题变得稍微复杂一些。

浏览器解析 HTML，构建 DOM 树，当解析到`<style>`标签时，样式信息开始被解析，CSSOM 被构建，但是它并不会影响到 HTML 的解析和 DOM 树的构建。

当 HTML 解析到`<script>`标签时，因为脚本有可能改变 DOM 内容，所以 HTML 的解析必须等到脚本执行完毕后再继续。

脚本又有可能操作 CSSOM ，所以脚本必须等到 CSS 解析完毕后才能执行。确保此刻 CSS 解析完成，脚本被交到 JS 引擎手里，由 JS 引擎执行。

当脚本执行完毕，HTML 继续解析，直到全部 HTML 解析完毕，DOM 树构建完成（触发 DOMContentLoaded 事件）。

## 脚本

web的模式是**同步**的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。

如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是**同步的**，会阻塞文档的解析直到资源被请求到。

这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为**defer**，以使其不阻塞文档解析，并在文档解析结束后执行。Html5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。

### JS 解释器的工作原理
浏览器在解析 HTML 文档的时候，遇到脚本，会交给 JS 引擎执行，那么 JS 引擎是如何执行脚本(evaluating script)的呢？

- 扫描全局变量，确定所有已声明的变量或函数名
- 顺序执行所有语句

当所有的语句执行完毕后，JS 解释器任务结束，主导权交到 HTML 解析器手中，浏览器继续解析 HTML 文档。

从上述过程，我们能看出浏览器解析渲染 HTML 文档是单线程的，除了发送外部资源请求的操作。


浏览器的工作原理是网站性能优化的基础知识。CSS 不会阻塞 HTML 的解析，但是会阻塞渲染，CSS 的解析会阻塞脚本的执行，而**脚本会阻塞 HTML 的解析**

### defer 和 async

当浏览器碰到 script 脚本的时候：

	<script src="script.js"></script>
没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

---
	<script async src="script.js"></script>
有 async，**加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）**。

---

	<script defer src="myscript.js"></script>
有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 **script.js 的执行要在所有元素解析完成之后**，DOMContentLoaded 事件触发之前完成。

---

## 浏览器的进程与线程

### 区分进程和线程


-  进程之间相互独立

-  多个线程在进程中协作完成任务

-  **一个进程由一个或多个线程组成**

-  同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）


### 浏览器是多进程的

- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。


在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）

#### 多进程的优势

* 避免单个page crash影响整个浏览器
* 避免第三方插件crash影响整个浏览器
* 多进程充分利用多核优势
* 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

### GUI渲染线程（重要）
* 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
* 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
* 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

### JS引擎线程

* 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
* JS引擎是单线程的
* JS引擎线程负责解析Javascript脚本，运行代码。
* JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
* 同样注意，**GUI渲染线程与JS引擎线程是互斥**的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。


### 事件触发线程

* 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
* 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
* 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
* 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

### 定时触发器线程

* setInterval与setTimeout所在线程
* 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
* 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
* 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

### 异步http请求线程

* 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
* 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。


## 浏览器内核中线程之间的关系


#### GUI渲染线程与JS引擎线程互斥
由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，
GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

#### JS阻塞页面加载
从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。

、假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。
然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。

所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

**js标签的加载是同步get加载，也会阻塞页面**，其他资源比如图片，虽然也都是get加载，但浏览器可以同时处理，可以认为不存在同步和异步之分

### 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：

* 解析html建立dom树
* 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
* 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
* 绘制render树（paint），绘制页面像素信息
* 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。
* 所有详细步骤都已经略去，渲染完毕后就是**load**事件了，之后就是自己的JS逻辑处理了

### load事件与DOMContentLoaded事件的先后
上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？

很简单，知道它们的定义就可以了：

当 **DOMContentLoaded** 事件触发时，仅当DOM加载完成，不包括样式表，图片。
(譬如如果有async加载的脚本就不一定完成)

当 **onload** 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。
（渲染完毕了）

**所以，顺序是：DOMContentLoaded -> load**

### css加载是否会阻塞dom树渲染？
这里说的是头部引入css的情况

首先，我们都知道：css是由单独的下载线程异步下载的。

然后再说下几个现象：

* css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
* 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

> 这可能也是浏览器的一种优化机制。
> 
> 因为你加载css的时候，可能会修改下面DOM节点的样式，
> 如果css加载不阻塞render树渲染的话，那么当css加载完之后，
> render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。
> 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，
> 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。

